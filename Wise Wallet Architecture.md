# Wise Wallet Architecture
## Component Diagram
![image](https://github.com/aappacode/Test-Wise-Wallet/blob/aappacode-assignment-2/Siema_Component_Diagram.jpg)

The above diagram shows how information flows from the client to the database. First, the client will visit the page, currently hosted at https://wise-wallet-h65n.onrender.com/, and any requested or changed information will be transferred via Hypertext Transfer Protocol Secure in a JSON format. Most React application data are sent to web-servers through JSON. The data is then at the web-server which displays the UI of Wise Wallet. During development, the web-server runs on the built-in React server and VITE v4.4.11 (a fast web builder) on local:http://localhost:5173/. Technically, React apps can also behave like web servers, so traditional web-servers like Nginx or Apache are not necessary. The web-server sends information/requests to the app-server, Node.js (with Express framework), which communicates with Firebase data (Authentication Realtime Database and Cloud Firestore) to communicate information through this diagram and "fulfill requests." To connect Firebase to the app-server, we used the SDK steps as outlined by Firebase and API calls to connect our app to the databases. 

## ER Diagram
![image](https://github.com/aappacode/Test-Wise-Wallet/blob/aappacode-assignment-2/Siema_ER_Diagram1.jpg)

The above diagram shows how the entity, a user, is related to a transaction document and a survey document. We are currently using the Firestore database, which is a NoSQL database, meaning there are no relations, but there are simple relationships, like one user has many transactions. The way we are "connecting" the documents and the profile is through the user's unique identifier, which is made upon account creation. In the ER diagram above, one user can have many transactions which include the user_id (to connect to the user), transaction_id, amount, date, and description. This is because one user can make many transactions. Additionally, the survey data is a one-to-one relationship including the user's first and last name, college and graduation information, budgeting information, contact number, and notification preferences. One user can have only one survey since it is part of the registration process (as a secondary to email/password authentication sign-up), and one survey is connected to only one user. Additionally, when a user wants to update their profile, selected information is taken from the user authentication realtime database (email) and the survey document (user_id,﻿ email﻿, firstName, lastName, college, graduationDate, phoneNumber, notificationPreferences﻿, notificationMethod﻿) to update the same user via their unique identifier. NOTE: phoneNumber is currently being integrated in the next iteration, so this reflects a future entity relationship diagram.

## UML Sequence Flow Diagram
![image](https://github.com/aappacode/Test-Wise-Wallet/blob/aappacode-assignment-2/Siema_Flow_Diagram.jpg)

The above diagram shows how a user can add their first transaction through their dashboard. The assumption is that they are already logged in because only authenticated logged-in users can see a dashboard and that the user has no previous transactions. When the user enters the transaction description, amount, and date into the form from the dashboard, the form onSubmit will use the firebase-config.js function, `addTransactionToDb(data)`, inside the AddTransactionForm.jsx file, to add the data (the description, amount, and date) to the Firestore Database Collection: User Transactions. There will be nothing returned to see for this particular sequence. However, we have implemented a `getTransactionFromDB(userID)` function in firebase-config.js, which will search the database by user_id to see the transactions made by the user, and then push each matching document to a list and return information after adding to the DB. So we can think of addTransactiontoDB and getTransactionFromDB as two parts that will return a piece of data. This list of data is captured: `const data = await getTransactionFromDB(currentUser.uid);` in the form file, and then the transaction form file will update the existing table with the new information added: `setTransactionList(data);`. After that is complete, I have marked the end of the lifeline of the form with an "X" since the form is reset to default (blank).
